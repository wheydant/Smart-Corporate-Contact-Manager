# Smart Corporate Contact Manager

## Spring Initializer – start.spring.io

1. Group – If project uploaded on maven’s site it needs to be unique, thus we have to follow standard to just reverse the domain name.

2. Artifact – Name of the project.
3.	Dependencies – Not needed to add all the dependencies at once, gradually add them.
    
    -	Spring Web – Manages web compatibility
    -	Thymeleaf – Our backend is been generated by backend only. We need template engine. To convert Spring Boot server to Dynamic HTML Response.
    ![alt text](image.png)

    - Data JPA – For SQL Database connection.
    - Validation – Bean Validation for Form validation.
    - Spring Security – Will Add later.
    - Outh2-client – Will Add later.
    - Model mapper – Will Add later.
    - Starter mail – Will add later.
    - *Lombok* – Annotation Library ready to user boiler plates.
    - Dev tools – Live reload.
    - MySQL Driver – For SQL Connection.

## Setup
1. DB 

-  src > main > resources > application.properties
        
    - url – tool:database:server:port/{db_name} username and password.
    - In SQL create schema > db_name. Columns will be generated by spring boot.

>**Note :** Ctrl + P helps to search anything from the project.

2. JPA
    
- ddl-auto – update is mandatory to reflect changes in database.

- Extra Details
    
    - Shows sql queries as we are learning to disable it when in production

    - If update is not set then schemas and tables wont be created

    - We have options like create, create-drop, validate etc. 

    - Can use dialect which automatically creates queries for specified database like mySQL, OracleSQL, postgreesSQL. Important if for some reason springboot fails to understand usually it is handled automatically.

    - Can use format_sql for formated version which is basically to learn sql in depth


## Basic Setup

[Internal Working of SpringBoot](https://youtu.be/tHDrxMklmPQ?si=KmiDBVNOzIb4gual)

Create file PageController which will control all the routing and all under com.sccm.controller

1. @Controller – We need a controller to handle a request. Controller can send dynamic data to HTML page. 
    
    - It returns a template which contains HTML src>main>resources>template>home.html if we are returning "home".

    - Dynamic data handling is done by taking Model as controller parameter. Adding any attribute to this model.

    - Extracting Data in HTML is done using thymeleaf `data-th-text=”${name}”` or `th:text = "${name}"` th stands for thymeleaf and displayed as text or th:href etc. data-th- are html friendly code, it will automatically populate that tag where it is mentioned. Using : method will highlight syntax error. 

    `<section th:replace="${content}"></section>`

2.	@RequestMapping(“{/url}”) – Makes a handler method which act as a return statement for the controller which usually returns name of the view.


```java
@Controller
public class PageController {

    @RequestMapping("/home")
    public String home(Model model){
        System.out.println("Home page Handler");
        model.addAttribute("name", "Welcome to Smart Corporate Contact Manager");
        model.addAttribute("paragraph", "Lorem ipsum, dolor sit amet consectetur adipisicing elit. Dolorum voluptatum quae amet optio adipisci voluptate, sint dolores minima consequuntur delectus, nihil sapiente consequatur praesentium saepe animi ducimus, esse architecto repellat a consectetur ipsum? Blanditiis repellendus eaque sint alias obcaecati molestiae magni quam quos voluptatibus assumenda deleniti voluptates, possimus et culpa?");
        model.addAttribute("link", "https://youtu.be/SAqi7zmW1fY?si=8CpQ6drnVwMlMLYl");
        //This is basically name of view.
        return "home";
    }
}
```
## Configuring [Tailwind](https://v3.tailwindcss.com/docs/installation)

- We can use Play CDN but its more for development purpose and not production.

- We have to initialize node in our project using `npm init -y` and add “type” = “module” in package.json. 

- Install tailwind `npm install -D tailwindcss` Initialize tailwind by `npx tailwindcss init` in tailwindconfig file add content path where the css content will be present.

- Add input and output css file to catch all the css changes used in our code. This output will be the main file which we would deploy add watch flag to make changes on runtime. `npx tailwind -i .\src\main\resources\static\css\input.css -o .\src\main\resources\static\css\output.css --watch`.

>**Note :** `npx tailwind -i .\src\main\resources\static\css\input.css -o .\src\main\resources\static\css\output.css --watch` Always add this to build input output css during live editing

- Add stylesheet of output file to insert css in our project  `<link rel="stylesheet" data-th-href="@{'/css/output.css'}"/>` Thyme leaf href is used with @ specifying relative path.
    
- Using Flowbite for components. 

## [Thymeleaf](https://www.thymeleaf.org/doc/articles/layouts.html) 

a.	Fragment
    
- Enables React type of component insertion in main.html in springboot, this react components are known as thymeleaf fragments. 

- Fragment can take variables and even markups to load individual components.

- Create a file which contains name of fragment ```<div class="fragment-tag" th:fragment="parent(x,y)">``` , Parameters can be accessed by ```<h1>Value of x is <span th:text="${x}"></span> </h1>```. The parameters are actually passed from child fragment to parent fragment. Refer 4th point.

- Thymeleaf Namespace

```html
<html lang="en"
th:fragment="parent(content, title, script)"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:th="http://www.thymeleaf.org">
```
    
- Use this fragment in any page. We can either insert or replace in base div. ```<div class="host-tag" th:insert="~{base :: parent('one', 'two')}">```, ~{filename :: fragment name} and One and two are the parameters passed.

- Using `th:replace` replaces the child's html.

- Passing markup from child to parent – ```<div class="host-tag" th:insert="~{base :: parent(~{::section})}">```, reference of section or any passing parameter below this div will be passed to parent. To pass via id/ class `th:replace="~{base :: parent(~{::#main-content})}"`/ `th:replace="~{base :: parent(~{::.main-content})}"`

- Fetched using ```<div class="fragment-tag" th:fragment="parent(content)">``` ```<div th:replace="${content}"></div>``` replace as we don’t want that div instead want to load the fragment.

- Dynamic use of Thymeleaf and Model passing model attribute as isLogin. `<div class="host-tag" th:replace = "${isLogin} ? ~{base :: parent(~{::section})} : ~{base :: error(.logon)}">`

b. Layouts

![alt text](image-1.png)

i.	Creating Base HTML which is act as a base template for all the common things like CSS file, thymeleaf namespace, flowbite plugin.

ii.	Creating a Child parameter which will take content from the fragment at the same time pass parameter to the parent and eventually displays it on our base page.

iii. Refer Fragments 7 & 8 points

```html
    <!-- Base -->
    <html lang="en" th:fragment="parent(content, title, script)">
        <title th:replace="${title}"></title>

    <!-- About -->
    <html lang="en" th:replace="~{base::parent(~{::#content},~{::title}, ~{::script})}">
```

>**Note :** For using href we use @ `<a data-th-href = "@{'/home'}">Home</a>`. 

## [Flowbite](https://flowbite.com/)

- Flowbite helps to make everything responsive.

- Static folders are directly accessible. 

### Dark Mode Toggle

- Using Font [awesome](https://fontawesome.com/) for icons/logo.
    
- We can use components directly without downloading using [cdn](https://cdnjs.com/libraries/font-awesome) link.
    
- localStorage an object of browser stores the data related to individual system and updates the theme.

- Passing theme and removal of old theme from html tag as a class is mandatory.

- Get theme - `let theme = localStorage.getItem("theme");`, Set theme - `localStorage.setItem("theme", theme)`, HTML class - `document.querySelector("html").classList.add(currentTheme);`


## Model and Entity

![alt text](image-2.png)

- Create Entities under com.sccm.entities

>**Note:** spring.jpa.hibernate.ddl-auto=update property must be set to reflect changes in DB

- Class is created with annotation Entity which acts as Object which will be mapped. Table annotation can be used to further specify details like custom table name, if not specified Entity's name will be considered as table name.

- All the parameters of the class are considered as the row to the table. Id annotation makes a parameter primary key, Column annotation can be used to assign further specifications like name, unique, nullable, length etc.

- We created an Enum for Providers, Enums are basically fixed parametric values.

- Getter, setter, constructor and builder can be made dynamically using **lambook** annotation.


- Mapping in Java Class

![alt text](image-3.png)

```java
@Entity(name = "user")
@Table(name = "users")
//Lambook
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class User {

    @Id
    private String userId;

    @Column(name="user_name", nullable=false)
    private String name;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
    private List<Contact> contacts = new ArrayList<>();
}

public class Contact {
    @Id
    private String id;

    @ManyToOne
    private User user;

    @OneToMany(mappedBy = "contact", cascade = CascadeType.ALL, fetch = FetchType.EAGER, orphanRemoval = true)
    private List<SocialLink> links = new ArrayList<>();
}
```

- One user can have multiple contacts and Many contacts can be associated with user

- Decoding `@OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)` mappedBy gives preference to Contact's user to be the governing column if it's not specified another table get created to facilitates bidirectional mapping. cascade deletes everything if user is deleted. FetchType.Lazy only runs query whenever its necessary. In links EAGER is used to fetch the associated links as soon as contacts are fetched. Orphans can be deleted.

- WorkBench > Database > Reverse Engineer

![alt text](image-4.png)

- `@GeneratedValue(strategy = GenerationType.IDENTITY)` Auto Increments the value of the id.

- `@Enumerated(value = EnumType.STRING) private Providers provider = Providers.SELF;` Using Enumerated as Annotation makes the value restrictions for only those strings.

## Sign Up Screen

### Front end 

- Using flowbite for easy element

- Grid is very strong so basically we have divided grid in 12 columns. `<div class="grid grid-cols-12">`. Blank div accounts for white space before our form helps to align it. `<div class="md:col-span-2 lg:col-span-3 xl:col-span-4"></div>` Specifying for all the screen sizes makes it dynamic -> sm - [0-12-0], sm - [2-8-2], sm - [3-6-3], sm - [4-4-4]. `<div class="col-span-12 md:col-span-8 lg:col-span-6 xl:col-span-4">`.

### Backend

- For form action specify thymeleaf action `<form class="space-y-6" data-th-action="@{'/do-register'}" method="post">`

- Inside controller specify value and method under RequestMapping `@RequestMapping(value = "/do-register", method = RequestMethod.POST)`

- To redirect to same register page `return "redirect:/login";`

- Create a class src/main/java > com.sccm > forms > UserForm.java. Name of the variables in the class should be the same as User Entity.

- Pass the object of UserForm in register controller function only.

- We can pass default value too for the form to fetch.

```java
public String registerPage(Model model) {
    UserForm userForm = new UserForm();
    // We can add default data also
    userForm.setName("Vedant");
    model.addAttribute("userForm", userForm);
    return "register";
}
```

- In the html view we can extract is by mentioning the `th:object` and `th:field` but th:field is followed by *.

    `<form data-th-action="@{'/do-register'}" method="post" data-th-object="${userForm}">`

    `<input type="text" name="name" id="name" placeholder="Enter here" required th:field="*{name}" />`

- Get data in do-register function `public String processRegister(@ModelAttribute UserForm userForm)`. Specify @ModelAttribute fetches models used in form.

**Managing Data with DB**

1. **Repository**
    
    For DB connection we need to create a Repo interface which extends JpaRepository. We can add function names `findBy<Attribute>` and Data JPA will automatically write its function body. But for this we create new package under com.sccm > repositories(package) > UserRepo(interface). This repo is used for Extra methods db related operation, custom query method,custom finder method.

    ```java
    @Repository
    public interface UserRepo extends JpaRepository<User, String>{
        //Function is automatically created by Spring Data GPA
        Optional<User> findByEmail(String email);
        //We can also add combination of two attributes
        Optional<User> findByEmailAndPassword(String email, String Password);
    }
    ```
2. **Services**

    Repository can be direct used under controller but to follow proper layered architecture we create services and its implementation. 

    - *Services*

        com.sccm > services(Package) > UserService(Interface). It contains all the methods which would be used. Optional is used to handle if the data is not present in DB, it is java.utils implementation only.A container object which may or may not contain a non-null value. If a value is present, isPresent() returns true. If no value is present, the object is considered empty and isPresent() returns false.Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() (returns a default value if no value is present) and ifPresent() (performs an action if a value is present).

        ```java
            public interface UserService {
            User saveUser(User user);
            Optional<User> getUserById(String id);
            Optional<User> updateUser(User user);
            void deleteUser(String id);
            boolean isUserExist(String userId);
            boolean isUserExistByEmail(String email);
            List<User> getAllUsers();
            // Add more methods related to user service logic.
        }
        ```
    - *Implementation*

        com.sccm.services > implementation(package) > UserServiceImpl(class). It implements UserServices and write function body. We use logger from `import org.slf4j.Logger;` to log details. Check [UserServiceImpl](../src/main/java/com/sccm/services/implementation/UserServiceImpl.java) for code. Autowired is used in place of Constructor injection ideally constructor injection should be used. We wrote new exception for userNotFound under com.sccm > helper(package) > ResourceNotFoundException(class) extending `RuntimeException`.

        ```java
        public class ResourceNotFoundException extends RuntimeException{
            public ResourceNotFoundException() {
                super("Resource not found");
            }
            public ResourceNotFoundException(String message) {
                super(message);
            }
        }
        ```

- Using everything in controller. Declare a variable with userService. and build it using the data from userForm. This is how builder works.

```java
User user = User.builder()
.name(userForm.getName())
.email(userForm.getEmail())
.password(userForm.getPassword())
.phoneNumber(userForm.getPhoneNumber())
.organization(userForm.getOrganization())
.about(userForm.getAbout())
.profilePic("src\\main\\resources\\static\\images\\profile.png")
.build();

User savedUser = userService.saveUser(user);
```

- But this method of using builder doesn't fetch default value. Thus we use normal constructor. Using like this fetches default value of provider as self earlier it was not getting fetch.

```java
User user = new User();
user.setName(userForm.getName());
user.setEmail(userForm.getEmail());
user.setPassword(userForm.getPassword());
user.setPhoneNumber(userForm.getPhoneNumber());
user.setOrganization(userForm.getOrganization());
user.setAbout(userForm.getAbout());
user.setProfilePic("src\\main\\resources\\static\\images\\profile.png");
User savedUser = userService.saveUser(user);
```

**Message Handling**

- Take alerts from flowbite create a thymeleaf fragment and insert it in register.
- To control Pop up of alert we can use it in request but we will use session in Handler. `public String processRegister(@ModelAttribute UserForm userForm, HttpSession session){}`. Then add attribute in session `session.setAttribute("message", "Registration Successful !");`.
- `<div th:if="${session.message}" th:fragment="messageBox">` Checking if session has message or not. Then displaying the message `<span th:text="${session.message}"></span>`.

>**Note :** But heres a catch if once user has register and he refreshes the screen the message will still exist in his session indicating already register.

- Making Message dynamic under helper create Message enum containing type of message. Create a class of message which has content and type. To use default value in builder we need to use `@Builder.Default`.

```java
public class Messages {
    private String content;
    @Builder.Default
    private MessageType type = MessageType.blue;
}
```

- Using it in controller - `Messages message= Messages.builder().content("Registration Successful !").type(MessageType.green).build();`

- Fetching in Message.html using `<div th:if="${session.message}" th:object="${session.message}" th:fragment="messageBox">` and fetching content using `<span th:text="*{content}"></span>`

**Important**

>**Note :** Message html changing class dynamically - `<div th:if="${session.message}" th:object="${session.message}" th:fragment="messageBox" th:classappend="*{'text-'+type+'-800  border-'+type+'-300 bg-'+type+'-50 dark:text-'+type+'-400  dark:border-'+type+'-800 dark:bg-'+type+'-900'}" id="alert-border-3" class="mt-2 flex items-center p-4 border-t-4" role="alert">`

**Important**

- Removing message from session is done by creating a helper class.RequestContextHolder - Holder class to expose the web request in the form of a thread-bound RequestAttributes object we extract requestAttributes and type cast RequestAttributes to ServletRequestAttributes to get request and get session via it. As getRequestAttributes can throw null pointer exception so wrap in a try catch block.

```java
@Component
public class SessionHelper {
    public static void removeMessage(){
        try {
            System.out.println("Removing Message from session");
            HttpSession session = ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest().getSession();
            session.removeAttribute("message");   
        } catch (Exception e) {
            System.out.println("Error in SessionHelper: "+ e);
            e.printStackTrace();
        }
    }
}
```

- Calling this method from HTML. `<th:block th:text="${@sessionHelper.removeMessage()}"></th:block>`. As we have specified @Component thus we can directly use sessionHelper as an object and call it's function.

**Form Validation**

- spring-boot-starter-validation will be used for validation. Annotations used for the same are `@Size(min = 8, max = 12, message = "Invalid Phone Number") @NotBlank(message = "Phone Number is required") @Email(message = "Invalid Email Id") @Pattern(<regex expression>)`

- In Page Controller we have to add the following `public String processRegister(@Valid @ModelAttribute UserForm userForm, BindingResult rBindingResult,HttpSession session)` and just need to check is error exists in rBindingResult `if(rBindingResult.hasErrors())return "register";`

- In Register.html first remove onClient form check `<form novalidate>` then  userForm object already has all the error regarding attributes. #fields: This is a built-in Thymeleaf object that provides access to information about form fields and their validation status, error can be extracted using .hasError('<field name>'). Error can be simply extracted using *{<field name>}. `<p th:if="${#fields.hasErrors('organization')}" id="filled_error_help"><span th:errors = "*{organization}">Some error message.</span></p>`. Additionally I am removing reset button when there are errors. ` <div th:if="${!#fields.hasErrors()}"> Wrong Input? <button type = "reset" >Rest Details</button></div>`.


## Spring Security

We will protect all the url followed by /user. Create new controller UserController under `com.sccm.controller`, it will have all the url's following user.

>**Note :** In `@RequestMapping(value="/dashboard", method=RequestMethod.GET)` if we are passing 2 variable we need to specify value="". If we are just using @RequestMapping than no need to add value and method is defaulted to GET. `@RequestMapping("/dashboard")`

Just by downloading [Springboot Starter Security](https://docs.spring.io/spring-security/reference/getting-spring-security.html), automatically a login page appears when we try to access our URL with credentials.

### Thus types of user configuration -

1. Automatic user configuration

    >**Note :** 'user' : user and 'password' : Auto-generated and specified in console. 

2. Properties file

    We can specify custom user password under `src>main>resources>application.properties` `spring.security.user.name=admin spring.security.user.password=admin`.

3. Dynamic users 

    We want to make it dynamic for all the user in DB they can login.

    Create a new package `com.sccm` > config inside it create a class SecurityConfig. 

    >**Note :**A SecurityConfig class is typically created in Spring Boot applications to define and customize the security configurations using Spring Security. 

    This class, often annotated with @Configuration and @EnableWebSecurity, allows for specifying security rules, authentication mechanisms, authorization policies, and other security-related settings.

    - In-Memory 

        If user is already present i.e. universal User like admin > admin in local memory we can user in memory service. We don't usually use this in production only used for testing, prototypes and demos.

        ```java
        @Configuration
        public class SecurityConfig {
            @Bean
            public UserDetailsService userDetailsService(){
                //User from .security
                BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
                UserDetails user1 = User
                    .withUsername("admin")
                    //Encoder is mandatory
                    .password(encoder.encode("admin"))
                    .roles("ADMIN", "USER")
                    .build();

                var inMemoryUserDetailsManager = new InMemoryUserDetailsManager(user1);

                return inMemoryUserDetailsManager;
            }
        }
        ```

        UserDetailsService bean in Spring Security, which is responsible for providing user information (username, password, roles) used for authentication UserDetailsService is an interface Spring Security uses to load user data during login. We create a password encoder to securely hash passwords using the BCrypt algorithm. Storing plain text passwords is not secure, and BCrypt adds hashing + salting.

    - DB Link

    >**Note :** Most important and production level use

    When login request comes for username and password AuthenticationProvider is trigger. We use DaoAuthenticationProvider which has methods to configure UserDetails and PasswordEncoder.

    Spring security uses UserDetails to deal with all the methods to validate users. Rather than creating new class we extend our [User](../src/main/java/com/sccm/entities/User.java) to implement userDetails and include the unimplemented methods.

    One Key method is getAuthorities() which specifies the roleList each user is assigned with. Stream part is interesting.
    ```java
    public class User implements UserDetails{
        ...
        //To fetch all the roles of the users, it is list as user can be admin/user/client
        @ElementCollection(fetch = FetchType.EAGER)
        private List<String> roleList = new ArrayList<>();

        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() {
            //We can return normal List of String we need Collection which extends GrantedAuthority 
            Collection<SimpleGrantedAuthority> roles = roleList.stream().map(role -> new SimpleGrantedAuthority(role)).collect(Collectors.toList());
            return roles;
        }
    }
    ```

    Need to add this part in UserServiceImpl also. Added encoder and list on roles. Hardcoding values is not a good practice thus we create new class under `com.sccm.helper` AppConstants and added `public static final String ROLE_USER = "ROLE_USER";`.

    ```java
        @Autowired
        private PasswordEncoder passwordEncoder;
        @Override
        public User saveUser(User user) {
            //user id needs to be generate unique and randomly
            String userId = UUID.randomUUID().toString();
            user.setUserId(userId);
            //Password encoding
            user.setPassword(passwordEncoder.encode(user.getPassword()));
            //Role list
            user.setRoleList(List.of(AppConstants.ROLE_USER));
            logger.info(user.toString());
            //Default profile pic
            return userRepo.save(user);
        }
    ```

    Now finally we create our custom userDetail service which implements UserDetailService for authentication under `com.sccm.services.implementation` > class SecurityCustomUserDetailService. loadUserByUsername is the main method which fetches details about the user for authentication, findByEmail uses Optional so we need to throw error if not found.

    ```java
        @Service
        public class SecurityCustomUserDetailService implements UserDetailsService{

            @Autowired
            private UserRepo userRepo;

            @Override
            public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
                //Load our user details
                return userRepo.findByEmail(username).orElseThrow(() -> new UsernameNotFoundException("User not found with this email -> " + username));
            }

        }
    ```

    Finally our UserConfig looks like
    ```java
    @Configuration
    public class SecurityConfig {



        @Autowired
        private SecurityCustomUserDetailService userDetailService;

        @Bean
        public AuthenticationProvider authenticationProvider(){
            //DaoAuthenticationProvider has all the methods to register the service
            DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();

            //User detail service object :
            daoAuthenticationProvider.setUserDetailsService(userDetailService);
        
            //Password encoder object but we are using direct
            daoAuthenticationProvider.setPasswordEncoder(passwordEncoder());
            return daoAuthenticationProvider;
        }

        @Bean
        public PasswordEncoder passwordEncoder(){
            return new BCryptPasswordEncoder();
        }
    ```

This will secure all the url's but we need to free some urls like login, register and home thus we need to add this security to particular routes. Thus in security config we add FilterChain. It calls authorizeHttpRequests internally which takes a lambda function which has authorizeHttpRequest on which we can perform the functions.

>**Note :** But the matchers are ordered specific thus generalize permissions should be last and specific important permissions should precede other.

```java
    httpSecurity.authorizeHttpRequests((authorize) -> {
        // authorize.requestMatchers("/home", "/register")permitAll();
        authorize.requestMatchers("/user/**").authenticated();
        authorize.anyRequest().permitAll();
    });
```


### User [Login](https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/form.html) 

But now as we have hampered with existing functionality we are not redirected to login url on hitting secured urls to add this we add `httpSecurity.formLogin(Customizer.withDefaults());`

To redirect to our login page we use `formLogin.loginPage("/login");` and login form gets submitted to `loginProcessingUrl("/authenticate")`. Method chaining we can either write `formLogin.loginPage("/login"); formLogin.loginProcessingUrl("/authenticate");` or chain it `formLogin.loginPage("/login").loginProcessingUrl("/authenticate");`. We can also add lots of parameters as shown in the code.

```java
    httpSecurity.formLogin(formLogin ->{
        formLogin.loginPage("/login")
        .loginProcessingUrl("/authenticate")
        // Changed from successForwardUrl defaultSuccessUrl perform client side rendering which is better for login 
        // .successForwardUrl("/user/dashboard")
        //In successForwardUrl we use server side which makes the form to resubmit it again which causes error
        .defaultSuccessUrl("/user/dashboard", true)  
        .failureUrl("/login?error=true")
        .usernameParameter("name")
        .passwordParameter("password")
        // .failureHandler(new AuthenticationFailureHandler() {
        //     @Override
        //     public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
        //             AuthenticationException exception) throws IOException, ServletException {
        //         // TODO Auto-generated method stub
        //         throw new UnsupportedOperationException("Unimplemented method 'onAuthenticationFailure'");
        //     }
        // })
        // .successHandler(new AuthenticationSuccessHandler() {
        //     @Override
        //     public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
        //             Authentication authentication) throws IOException, ServletException {
        //         // TODO Auto-generated method stub
        //         throw new UnsupportedOperationException("Unimplemented method 'onAuthenticationSuccess'");
        //     }
        // })
        ;
    });
```

We ran into a problem where `.successForwardUrl("/user/dashboard")` didn't work but `.defaultSuccessUrl("/user/dashboard", true)` worked. Because

1. defaultSuccessUrl redirects the client (browser) to `/user/dashboard` using a 302 HTTP redirect. So after login, the browser makes a new GET request to `/user/dashboard`.
2. .successForwardUrl forwards the request on the server-side after login — meaning: 
    - Spring does not tell the browser to go to a new URL.
    - It internally dispatches the login request to /user/dashboard.
    - HTTP method remains POST (because login form submits a POST).

>**Note :** Most of the time, defaultSuccessUrl(...) is preferred because it avoids double form submission issues. It aligns with how most web apps behave after login.

### User Logout

Like login default functionality was hampered default logout functionality was also hampered which needs to be explicitly specified. Using

```java
    //Configure Logout page
    httpSecurity.logout(logoutForm -> {
        //By default /logout uses get request.
        logoutForm.logoutUrl("/logout")
        .logoutSuccessUrl("/home");
    });
```

But this fails as default logout spring security uses GET request to logout. But spring security enables CSRF token by default which only permits POST request to tackle CSRF attacks so either we can do two things.

1. Write custom logout form which caters to POST request.
2. Turn off CSRF token 

Doing the later one for temporary fix

`httpSecurity.csrf(AbstractHttpConfigurer::disable);` AbstractHttpConfigurer has a method to disable csrf we are simply using method reference.

## Login with google

[OAuth2 client](https://mvnrepository.com/artifact/org.springframework.security/spring-security-oauth2-client/6.5.0) dependency needs to be added in the project, it already has spring security in it thus if we simply add OAuth 2 still we could configure everything regarding security.

We need to add providers client id and client secret.
For [Google](https://console.cloud.google.com/welcome/new) > Create new project > API & Services > OAuth Consent screen > 

Video steps are different the Dashboard looks different but isn't hard to go around instead of credential we have overview > Create OAuth client.
>**Note :** AUthorized redirect URI specifies on which URL user will be redirected once authorized. This is predefined URL by springboot and if any change leads to mismatch `http://localhost:8081/login/oauth2/code/google`

Thus after creation client id and client secret is generated. use it in application.properties
```properties
spring.security.oauth2.client.registration.google.client-name=google
spring.security.oauth2.client.registration.google.client-id={Client Id}
spring.security.oauth2.client.registration.google.client-secret={Client Secret}
spring.security.oauth2.client.registration.google.scope=email,profile
```
Adding the Oauth2 in security config will enable the google login
```java
    //Default login page
    httpSecurity.oauth2Login(Customizer.withDefaults());
```
Login Logout functionality works just fine.
Basically when default login google button is triggered it redirects to [/oauth2/authorization/google](http://localhost:8081/oauth2/authorization/google)

Adding Social Buttons on login.html and assigning above href to the buttom
>**Note :** Shorthand to add div with class `div.social-buttons-container`

### User Configuration

Using our custom login page security Config file will include - 
```java
    @Autowired
    private OAuthAuthenticationSuccessHandler handler;
    //Customized page
    httpSecurity.oauth2Login(oAuth -> {
        oAuth.loginPage("/login")
        .successHandler(handler)
        ;
    });
```
We Create OAuthAuthenticationSuccessHandler to store data coming from the OAuth into the DB and to configure successURL. Create new class under config itself > OAuthAuthenticationSuccessHandler.java and implement AuthenticationSuccessHandler where we have to implement onAuthenticationSuccess method. 
>**Note :** `authentication.getPrincipal()` holds the user data and `user.getAttributes()` store all the attributes we get from the login Provider. 

```java
@Component
public class OAuthAuthenticationSuccessHandler implements AuthenticationSuccessHandler {

    @Autowired
    private UserRepo userRepo;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
            Authentication authentication) throws IOException, ServletException {
                //Save Data before redirect
                DefaultOAuth2User user = (DefaultOAuth2User)authentication.getPrincipal();

                String email=user.getAttribute("email").toString();
                String name=user.getAttribute("name").toString();
                String picture=user.getAttribute("picture").toString();

                User dbUser = new User();
                dbUser.setEmail(email);
                dbUser.setName(name);
                dbUser.setProfilePic(picture);
                dbUser.setPassword("password");
                dbUser.setUserId(UUID.randomUUID().toString());
                dbUser.setProvider(Providers.GOOGLE);
                dbUser.setEnabled(true);
                dbUser.setEmailVerified(true);
                dbUser.setProviderUserId(user.getName());
                dbUser.setRoleList(List.of(AppConstants.ROLE_USER));
                dbUser.setAbout("User created using google login");

                User existingUser = userRepo.findByEmail(email).orElse(null);
                if(existingUser == null){
                    userRepo.save(dbUser);
                }

                //Using response
                // response.sendRedirect("/user/dashboard");
                //Using RedirectStrategy
                new DefaultRedirectStrategy().sendRedirect(request, response, "/user/dashboard");
    }
}
```
We can redirect user either by using response or using RedirectStrategy() which is good practice.

## Login with Github

Go to [https://github.com/settings/developers](https://github.com/settings/developers) add homepage URL - [http://localhost:8081](http://localhost:8081/) same done with google and callback URL as [http://localhost:8081/login/oauth2/code/github](http://localhost:8081/login/oauth2/code/github).
Uncheck webhook option. Account Permission > Profile > read and write. Account Permission > Email Permission > Only read.
After app creation we get client id and can generate client secret.

Each provider gives different attributes check the attributes using - 
```java
    oAuthUser.getAttributes().forEach((key, value) ->{
        logger.info("{} => {}", key, value);
    });
```

## Using Logger

Implement logger from `org.slf4j.Logger`. Create a logger which is class specific and use logger.info() to display data like System.out.println().

```java
    Logger logger = LoggerFactory.getLogger(OAuthAuthenticationSuccessHandler.class);

    logger.info("OAuthAuthenticationSuccessHandler");
    logger.info(user.getName());

    user.getAttributes().forEach((key, value) ->{
        logger.info("{} => {}", key, value);
    });

    logger.info(user.getAuthorities().toString()); -> this gives all the authorities we checked while on google cloud

    User existingUser = userRepo.findByEmail(email).orElse(null);
    if(existingUser == null){
        userRepo.save(dbUser);
        logger.info("User saved: " + email);
    }
```

## Fetching User details post login

We can inject Authentication in request mapping. Create a Helper class inside sccm.helpers which will have function to fetch username/user email.

```java
    @RequestMapping(value="/profile", method=RequestMethod.GET)
    public String userProfile(Authentication authentication) {
        String name = getEmailOfLoggedInUser(authentication);
```

In Helper class, refer OAuthAuthenticationSuccessHandler how we extracted data to store in DB.
```java
public class Helper {
    public static String getEmailOfLoggedInUser(Authentication authentication){

        //Provider logic
        if(authentication instanceof OAuth2AuthenticationToken){
            var oAuth2AuthenticationToken = (OAuth2AuthenticationToken)authentication;

            var clientId = oAuth2AuthenticationToken.getAuthorizedClientRegistrationId();

            var oAuth2User = (OAuth2User)authentication.getPrincipal();
            String username = "";

            //Google
            if(clientId.equalsIgnoreCase("google")){
                username = oAuth2User.getAttribute("email").toString();
            }
            //Github
            else if(clientId.equalsIgnoreCase("github")){
                username = oAuth2User.getAttribute("email") != null ? oAuth2User.getAttribute("email").toString() : oAuth2User.getAttribute("login").toString() + "@gmail.com";
            }

            return username;
        }else{
            //simple
            return authentication.getName();
        }
    }
}
```

We have fetched the email so we need a method to fetch user from db with this email id. Add method getUserByEmail UserService `User getUserByEmail(String email);` and add it's implementation in UserServiceImpl
```java
    @Override
    public User getUserByEmail(String email) {
        return userRepo.findByEmail(email).orElse(null);
    }
```

Now either we can do 2 things just add the userDetail in one requestMapping or add it in every requestMapping and we can access it if user is logged in else it would be null. Thus we create RootController inside sccm.controller and Annotate it with `@ControllerAdvice` and make a method which will perform all the fetching and annotating it with `@ModelAttribute` which make this method common to all the models in every requestMapping.

```java
@ControllerAdvice
public class RootController {

    private Logger logger = LoggerFactory.getLogger(this.getClass());
    @Autowired
    private UserService userService;
    
    @ModelAttribute
    public void addLoggedInUserInformation(Model model, Authentication authentication){
        //If user is not logged in
        if(authentication == null) return;
        logger.info("Adding logged in user info to the model");
        String userEmail = getEmailOfLoggedInUser(authentication);
        User user = userService.getUserByEmail(userEmail);
        model.addAttribute("loggedInUser", user);
    }
}
```

Access the data in any html using `<h1 th:text="${loggedInUser.name}"></h1>`.

## Dashboard & Profile page

We separated our base.html on the basis of loggedInUser. And added new Nav bar + Side bar from flowbite used help of claude to make UI uniform.

```html
<!-- if user is logged in -->
<body th:if="${loggedInUser}">
<!-- if user is not logged in -->
<body th:unless="${loggedInUser}">
```





## Important Annotations

1. @Controller – We need a controller to handle a request. Controller can send dynamic data to HTML page.
2. @RequestMapping(“{/url}”) – Makes a handler method which act as a return statement for the controller which usually returns name of the view.
3. @Entity(name = "user") - Class is created with annotation Entity which acts as Object which will be mapped
4. @Table(name = "users") - Helps to specifiy more attributes to Entity.
5. Lambook
	- @Getter
	- @Setter
	- @AllArgsConstructor
	- @NoArgsConstructor
	- @Builder
6. @Id - Makes the parameter as Primary Key.
7. @Column(name="user_name", nullable=false) - Specify column attributes.
8. @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true) / @ManyToOne - Mapping Anottations
9. @GeneratedValue(strategy = GenerationType.IDENTITY) - Auto - Increments the value of the paremeter to be inserted into table.
10. @Enumerated(value = EnumType.STRING) Specifies column type as Enumerated i.e. restricting the values column can take.
11. @ElementCollection(fetch = FetchType.EAGER) if we are using List as column.
12. @ModelAttribute - Fetching model from the screen.
13. @Component - The @Component annotation in Spring Boot is a core annotation used to mark a class as a Spring-managed component. Its primary function is to indicate that the annotated class should be automatically detected and registered as a Spring Bean within the Spring Inversion of Control (IoC) container. Basically specifying class as component gives us power to make it's object without implicitly declaring one.
14. @Repository - The @Repository annotation in Spring Boot indicates that a class serves as a "repository" component in the application's persistence layer. It is a specialization of the more general @Component annotation and signifies that the annotated class is responsible for data access and manipulation operations, often interacting with a database or other data sources.
15. @Builder.Default - Specifying it helps to build object using .builder with default values.
16. @Bean - An instance of a class managed by the Spring container.
17. @Configuration - The @Configuration annotation in Spring Boot signifies that a class is a source of bean definitions. When Spring encounters a class annotated with @Configuration, it understands that this class will define and configure various components (beans) that Spring will manage throughout the application's lifecycle. Methods within a @Configuration class that are annotated with @Bean will create and return instances of these components, making them available for injection and use by other parts of the application. Essentially, @Configuration classes act as the blueprint for how Spring should assemble and manage the application's components.
18. @Autowired - The @Autowired annotation in the Spring Framework facilitates automatic dependency injection. It instructs the Spring IoC (Inversion of Control) container to automatically resolve and inject collaborating beans into other beans. It is used when using components in a bean.
19. @ControllerAdvice - Root controller everything written in this will be transferred to all the controllers.
20. @ModelAttribute - All the models under the controller will get access to the model attribute mentioned in it.